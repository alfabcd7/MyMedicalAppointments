Como muchos compañeros han expresado , **todos nos hemos perdido pero animo , sigue viendo el video una y otra y otra vez hasta que lo comprendas.**
Por consiguiente Tratare de describir lo mas explicativo posible para ayudarte a acelerar el proceso :
**1.-** La profesora hace uso de la **interfaz Map** en especifico  **la clase Treemap**, que en clases anteriores podrás observar toda la documentación que dejaron acerca de esta Interfaz entre otras , para que no tengas que ir hasta allá te dejo un resumen para TreeMap.
**2.- Cuando Se utilizan Estructuras de Arbol?**
 Usar los diagramas de árbol **al trabajar con grandes cantidades de datos con una estructura jerárquica**. Cuando existe una correlación entre el color y el tamaño, ++**los diagramas de árbol ayudan a identificar patrones que, de otro modo, serían difíciles de ver.**++
**++Los diagramas de árbol también son eficaces para facilitar la lectura porque muestran grandes volúmenes de información en una misma pantalla++**. Quienes los observan pueden profundizar en una categoría específica para hacer más investigaciones.
     [   https://help.highbond.com/helpdocs/highbond/es/Content/visualizations/interpretations/charts/treemap_chart.htm](url)
 **3.-** Por tanto Eligio hacer uso de Map ya que  **es una estructura mas compleja que un "Collection"**, En la que **_++su mayor particularidad es venir enparejado con otro dato++_**, es decir describes **la llave** **y el elemento emparejado a esta**.
            **3.1.-** ++Es algo parecido a como funciona la llaves en las bases de datos++ , Un ejemplo podría ser la lista de alumnos en al escuela con la cual pasaban asistencia , si recuerdas o si te ha pasado , cuando tocaba la hora de dar examen, habían maestros que te pedían escribir en la parte superior derecha del examen el numero que te correspondía en la lista de asistencia , es decir de 60 alumnos , Carlos alfredo soria era el numero 45 de la lista de asistencia , por tanto **++con el simple numero de 45 que seria mi Key , describe algo como : El alumno inscrito Carlos Alfredo Soria.++**
**4.- Los map se declara de la siguiente forma :**
             `Map<Integer , String> treemap = new TreeMap <Integer,String>();`
          **4.1.-** En la sintaxis diamante lo que se hace es especificar primeramente ++el Key(Integer) y Despues el Value(String)++.
           **4.2.-** En la funcionalidad TreeMap : **El mapa los ordena de forma natural , es decir si ingresamos enteros , los ordenara de menor a** 
                        **mayor.**
.
.
.

**++Describiendo en el video :++**

 **1.-** Por el minuto 02:45 la profesora hace un repaso de la "estructura de datos"  la cual se hizo a partir de **los diferentes elementos de abstracción** :
 En dicha estructura tenemos una lista de doctores , en el q cada doctor se crea mediante la clase Doctor , generando dicha lista como la que 
 describe en el video...
doctor1 , doctor2 , doctor3 , etc. (Recuerda que ella creo tres doctores como ejemplo).
**1.1.-** **Cada uno** de estos doctores **tiene un ArrayList de citas disponibles (fechas)** , a este ArrayList se le dio el nombre de **_availableAppointments_**, significa que por cada objeto Doctor ++se podría generar++ una lista de fechas , dicha lista ++en caso de haber fechas y horarios++ se almacena en el ArrayList ya antes mencionados.
 
Nos Muestra una estructura de este tipo :

            // [Doctors] 
           //1.- doctors1
                //1.- fecha1
                //2.- fecha2
           //2.- doctors2
           //3.- doctors3

 **2.-** En _**doctorsAvailableAppointments**_ se almacenara una **lista de doctores pero q tengan citas confirmadas (OJO)** , es decir , aquellos doctores que se dieron la molestia de ingresar a la App e introducir las fechas y horarios para los que ellos están disponibles.
 **2.1-**  **En la siguiente linea :**
`for (int i = 0; i < doctorsAvailableAppointments.size() ; i++){`
De la clase ++UiPatientMenu++ fue escrita con la idea de tener  **performance** , ya que con el método **size()** aplicado al ArrayList _**doctorsAvailableAppointments**_  es posible saber el numero exacto de objetos(doctores) que vamos a utilizar para imprimir en pantalla.
 Sin el ArrayList mencionado podría suceder que tengamos 25 doctores y no es correcto tener que recorrer 25 objetos en busqueda de Fechas Disponibles cuando es mucho mas eficiente almacenar en ++una lista de doctores(Que puede que sean 5 o menos de 25) que **Si** han confirmado++ para brindar atención(Al confirmar atención se tiene la seguridad de que existe fechas disponibles dentro del ArrayList **_availableAppointments_** de cada doctor en particular) , además de tener información validada , accesible(recordar que el Arraylist _**doctorsAvailableAppointments**_ es Stactic) y a la mano.
.
.
Por tanto se concluye que si un Doctor esta listado en **_doctorsAvailableAppointments_**  significa que hay una lista de fechas disponible en  **_availableAppointments_** para ese doctor en particular.
**3.-** **En la siguiente linea :**
 `ArrayList<Doctor.availableAppointment> availableAppointments = doctorsAvailableAppointments.get(i).getAvailableAppointments();`
**3.1-** Se crea un nuevo ArrayList llamado _++**availableAppointments**++_ del tipo de Objeto **Doctor.availableAppointment** , recordando que es un tipo de objeto de la subclase **availableAppointment**
  .....YYYYYYYYYYY Si!!!!! ++tiene el mismo nombre que el ArrayList declarado anteriormente en la clase Doctor++ , pero tiene su motivo , Te lo explico :
La idea del declarar dicha linea es la de **recorrer y obtener cada uno de los doctores** listados en _**doctorsAvailableAppointments**_
que se los obtiene haciendo uso del metodo _**get()**_ de la **clase ArrayList** e indicando el índice mediante la variable **i** que esta siendo iterado por el **For-i**.
Por tanto al instante de Obtener el Objeto Doctor en especifico mediante la iterancia del **For-i** también **se obtiene acceso** al ArrayList _**availableAppointments**_  ++pero a el _**availableAppointments**_ de la clase Doctor++, que recordemos **es donde esta almacenado** la lista de Fechas y Horarios para ese Objeto (doctor) en particular.

**3.2.-** Siendo el objetivo final asignar el ArrayList de **++availableAppointments de la clase Doctor++**  al
     ArrayList de  **++availableAppointments de la clase UiPatientMenu++** , ya que es bueno recordar que el  **++availableAppointments de la clase Doctor++**  NO es **Static** sino **Private** y se accede a el mismo  mediante **++el método de la clase Doctor++** , _**getAvailableAppointments()**_ .
.
.
.
por tanto concluir que la idea fundamental de la presente linea de código es la de **extraer un buen pedazo de información desde una clase (En este caso Doctor)  para almacenar dicha informacion en la clase de donde esta siendo declarada dicha linea (UiPatientMenu)**.